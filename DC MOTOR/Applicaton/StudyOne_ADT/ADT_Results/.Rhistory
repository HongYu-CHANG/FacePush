setwd("~/")
update.packages()
## get packages installed
packs = as.data.frame(installed.packages(.libPaths()[1]), stringsAsFactors = F)
## and now re-install install packages using install.packages()
install.packages(packs$Package)
install.packages(packs$Package)
install.packages(packs$Package)
install.packages(packs$Package)
packs = as.data.frame(installed.packages(.libPaths()[1]), stringsAsFactors = F)
packs
library(httr)
update.packages(ask = FALSE)
library(devtools)
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
print
label
labels
argmax
axis
argmax <- function(arr, axis = NULL) {
# Returns the indices of the maximum values along an axis.
# if (length(dim(arr)) != 3) stop("input array doesn't have correct dimension")
if (is.null(axis)) {
which.max(arr)
} else {
apply(arr, MARGIN = axis, which.max)
}
}
argmax
a <- mat(1:6, 2, 3)
a <- matrix(1:6, 2, 3)
a
argmax(a)
argmax(a, axis = 0)
argmax(a, axis = 1)
argmax(a, axis = 2)
is.zero
dim (a)
argmax <- function(arr, axis = NULL) {
# Returns the indices of the maximum values along an axis.
if (axis == 0 || axis > max(dim(arr))) stop("axis doesn't fit the dimension if input array")
# axis in numpy is different with R
if (is.null(axis)) {
which.max(arr)
} else {
apply(arr, MARGIN = axis, which.max)
}
}
argmax(a)
NULL == 0
argmax(a, 5)
NULL > 3
argmax <- function(arr, axis = 0) {
# Returns the indices of the maximum values along an axis.
if (axis > max(dim(arr))) stop("axis doesn't fit the dimension if input array")
# axis in numpy is different with R
if (axis == 0) {
which.max(arr)
} else {
apply(arr, MARGIN = axis, which.max)
}
}
argmax(a)
argmax(a, 2)
argmax(a, 1)
argmax(a, 3)
argmax <- function(arr, axis = 0) {
# Returns the indices of the maximum values along an axis.
if (axis > max(dim(arr))) stop("axis doesn't fit the dimension of input array")
# axis in numpy is different with R
if (axis == 0) {
which.max(arr)
} else {
apply(arr, MARGIN = axis, which.max)
}
}
max(dim(arr))
max(dim(a))
argmax <- function(arr, axis = 0) {
# Returns the indices of the maximum values along an axis.
if (axis > length(dim(arr))) stop("axis doesn't fit the dimension of input array")
# axis in numpy is different with R
if (axis == 0) {
which.max(arr)
} else {
apply(arr, MARGIN = axis, which.max)
}
}
argmax(a, 3)
t
?t
label.p.y.given.x <- function(p.y.given.x) {
t(argmax(p.y.given.x, axis = 3))
}
a = array(1:30, 3, 2, 5)
a
a <- array(1:30, c(3, 2, 5))
a
a <- array(1:30, c(3, 5, 2))
a
label.p.y.given.x(a)
clusters
alpha
a
a[:, :, 0]
a[, , 1]
tc
?stopifnot
getAnywhere(t.test)
getAnywhere(mean)
leibnitz_pi <- function(n = 10) {
stopifnot(is.numeric(n))
stopifnot(n > 0)
est <- 1
for (i in seq(length = n)) {
est <- est + (-1) ^ i / (2 * i + 1)
}
pi_est <- 4 * est
rslt <- list(pi_est = pi_est, n = n)
class(rslt) <- c("leibnitz_pi", "est_pi", class(rslt))
return(rslt)
}
leibnitz_pi(99)
# Implement generic print method for leibnitz_pi
print.leibnitz_pi <- function(x, ...) {
cat(x$pi_est, "(from the Leibnitz formula\n)")
}
print(leibnitz_pi(99))
# Implement generic print method for leibnitz_pi
print.leibnitz_pi <- function(x, ...) {
cat(x$pi_est, "(from the Leibnitz formula)\n")
}
print(leibnitz_pi(99))
methods("print")
methods("print")[grep("leibnitz", methods("print"))]
estpi.leibnitz_pi <- function(x, ...) {
x$estpi
}
estpi(leibnitz_pi(99))
estpi <- function(x, ...) {
UseMethod("estpi", x)
}
estpi.leibnitz_pi <- function(x, ...) {
x$estpi
}
estpi(leibnitz_pi(99))
estpi.leibnitz_pi <- function(x, ...) {
x$est_pi
}
estpi(leibnitz_pi(99))
estpi.leibnitz_pi <- function(x, ...) {
x$pi_est
}
estpi(leibnitz_pi(99))
90 * 0.8
leibnitz_pi(99)
print(leibnitz_pi(99))
attr(leibnitz_pi(99))
# Leibnitz formula for pi
leibnitz_pi <- function(n = 10) {
stopifnot(is.numeric(n))
stopifnot(n > 0)
est <- 1
for (i in seq(length = n)) {
est <- est + (-1) ^ i / (2 * i + 1)
}
pi_est <- 4 * est
rslt <- list(pi_est = pi_est, n = n)
class(rslt) <- c("leibnitz_pi", "est_pi", class(rslt))
return(rslt)
}
print(leibnitz_pi(99))
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
corex
rcorex <- function(n_hidden = 2, dim_hidden = 2, batch_size = 1e6, max_iter = 400,
n_repeat = 1, eps = 1e-6, alpha_hyper = c(0.3, 1.0, 500.0),
balance = 0.0, missing_values = -1, seed = NULL, verbose = False) {
dim_hidden <- dim_hidden  # Each hidden factor can take dim_hidden discrete values
n_hidden <- n_hidden  # Number of hidden factors to use (Y_1,...Y_m) in paper
missing_values <- missing_values  # Implies the value for this variable for this sample is unknown
max_iter <- max_iter  # Maximum number of updates to run, regardless of convergence
batch_size <- batch_size  # TODO: re-implement running with mini-batches
n_repeat <- n_repeat  # TODO: Run multiple times and take solution with largest TC
eps <- eps  # Change in TC to signal convergence
lam <- alpha_hyper[1]  # Hyper-parameters for updating alpha
tmin <- alpha_hyper[2]  # Hyper-parameters for updating alpha
ttc <- alpha_hyper[3]  # Hyper-parameters for updating alpha
balance <- balance # 0 implies no balance constraint. Values between 0 and 1 are valid.
set.seed(seed)  # Set for deterministic results
# change these following into R statements
verbose <- verbose
rslt <- list(dim_hidden = dim_hidden, n_hidden = n_hidden, missing_values = missing_values,
max_iter = max_iter, batch_size = batch_size, n_repeat = n_repeat,
eps = eps, lam = lam, tmin = tmin, ttc = ttc, balance = balance, verbose = verbose)
class(rslt) <- c("rcorex", class(rslt))
return(rslt)
#if (verbose > 0) {
# print options only
# np.set_printoptions(precision=3, suppress=True, linewidth=200) #
# print('corex, rep size: {}, {}'.format(n_hidden, dim_hidden)) #
#}
#if (verbose > 1) {
#  np.seterr(all='warn')
#}
#else {
#  np.seterr(all='ignore')
#}
}
rcorex()
rcorex <- function(n_hidden = 2, dim_hidden = 2, batch_size = 1e6, max_iter = 400,
n_repeat = 1, eps = 1e-6, alpha_hyper = c(0.3, 1.0, 500.0),
balance = 0.0, missing_values = -1, seed = NULL, verbose = FALSE) {
dim_hidden <- dim_hidden  # Each hidden factor can take dim_hidden discrete values
n_hidden <- n_hidden  # Number of hidden factors to use (Y_1,...Y_m) in paper
missing_values <- missing_values  # Implies the value for this variable for this sample is unknown
max_iter <- max_iter  # Maximum number of updates to run, regardless of convergence
batch_size <- batch_size  # TODO: re-implement running with mini-batches
n_repeat <- n_repeat  # TODO: Run multiple times and take solution with largest TC
eps <- eps  # Change in TC to signal convergence
lam <- alpha_hyper[1]  # Hyper-parameters for updating alpha
tmin <- alpha_hyper[2]  # Hyper-parameters for updating alpha
ttc <- alpha_hyper[3]  # Hyper-parameters for updating alpha
balance <- balance # 0 implies no balance constraint. Values between 0 and 1 are valid.
set.seed(seed)  # Set for deterministic results
# change these following into R statements
verbose <- verbose
rslt <- list(dim_hidden = dim_hidden, n_hidden = n_hidden, missing_values = missing_values,
max_iter = max_iter, batch_size = batch_size, n_repeat = n_repeat,
eps = eps, lam = lam, tmin = tmin, ttc = ttc, balance = balance, verbose = verbose)
class(rslt) <- c("rcorex", class(rslt))
return(rslt)
#if (verbose > 0) {
# print options only
# np.set_printoptions(precision=3, suppress=True, linewidth=200) #
# print('corex, rep size: {}, {}'.format(n_hidden, dim_hidden)) #
#}
#if (verbose > 1) {
#  np.seterr(all='warn')
#}
#else {
#  np.seterr(all='ignore')
#}
}
rcorex()
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
label_p_y_given_x <- function(p_y_given_x, ...) {
UseMethod("label_p_y_given_x", p_y_given_x)
}
label_p_y_given_x <- function(rcorex, ...) {
UseMethod("label_p_y_given_x", rcorex)
}
label_p_y_given_x.corex <- function(rcorex, ...) {
# Maximum likelihood labels for some distribution over y's
t(argmax(rcorex$p_y_given_x, axis = 3))
}
corex
rcorex()
label_p_y_given_x.rcorex <- function(rcorex, ...) {
# Maximum likelihood labels for some distribution over y's
t(argmax(rcorex$p_y_given_x, axis = 3))
}
label_p_y_given_x(rcorex())
rcorex
rcorex()
rcorex()$p_y_given_x
#
# @property in R?
ml_labels <- function(rcorex, ...) {
UseMethod("ml_lables", rcorex)
}
ml_labels.rcorex <- function(rcorex, ...) {
# maximum likelihood labels for trainging data
label_p_y_given_x()
}
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
seq(5)
seq(5-1)
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
install.packages("fread")
install.packages("data.table")
install.packages("tidyverse")
install.packages("shiny", "rmarkdown")
install.packages("shiny")
install.packages("rmarkdown")
install.packages("xgboost")
install.packages("ggmap")
install.packages("rgl")
install.packages("grep")
getAnywhere("grep")
install.packages("stringr")
install.packages("e1071")
install.packages("nnet")
setwd("~/Documents/_NILab_CrazyMotor/FacePush/DC MOTOR/Applicaton/StudyOne_ADT/./ADT_Results/")
all_files <- dir() [-length(dir())]
setwd("~/Documents/_NILab_CrazyMotor/FacePush/DC MOTOR/Applicaton/StudyOne_ADT/./ADT_Results/")
all_files <- dir() [-length(dir())]
dta_lst <- lapply(all_files, function(x) read.table(x, header = TRUE, sep = ','))
setwd("~/Documents/_NILab_CrazyMotor/FacePush/DC MOTOR/Applicaton/StudyOne_ADT/ADT_Results/")
all_files <- dir() [-length(dir())]
dta_lst <- lapply(all_files, function(x) read.table(x, header = TRUE, sep = ','))
all_files
all_files <- dir() [-c(length(dir()) - 1, length(dir()))]
dta_lst <- lapply(all_files, function(x) read.table(x, header = TRUE, sep = ','))
all_files
length(dir())
all_files <- dir() [-28:30]
setwd("~/Documents/_NILab_CrazyMotor/FacePush/DC MOTOR/Applicaton/StudyOne_ADT/ADT_Results/")
dir()
28:30
all_files <- dir() [-28:30]
all_files <- dir() [-c(28:30)]
all_files
dta_lst <- lapply(all_files, function(x) read.table(x, header = TRUE, sep = ','))
dta_all <- dta_lst[[1]][c("Tester.Name", "Counter", "Degree")]
for (i in 2:length(all_files)) {
dta_all <- rbind(dta_all, dta_lst[[i]][c("Tester.Name", "Counter", "Degree")])
}
dta_all
dta_all$Block <- as.factor(rep(all_files, each = 24))
all_files
dta_all$Block <- as.factor(rep(all_files, each = 24))
levels(dta_all$Block) <- c("haoran_3_1", "haoran_3_2", "haoran_3_3",
"KT_3_1", "KT_3_2", "KT_3_3",
"lolly_3_4", "lolly_3_5", "lolly_3_6",
"lynn_3_4", "lynn_3_5", "lynn_3_6",
"lywang_3_1", "lywang_3_2", "lywang_3_3",
"Ricky_3_1", "Ricky_3_2", "Ricky_3_3",
"Timo_3_1", "Timo_3_2", "Timo_3_3",
"TY_3_4", "TY_3_5", "TY_3_6",
"yichen_3_4", "yichen_3_5", "yichen_3_6")
temp_degree <- NULL
for (i in 20:24) {
temp_degree <- rbind(temp_degree, subset(dta_all, Counter == i))
}
mean(temp_degree$Degree)
sd(temp_degree$Degree)
last_five_degree_m <- mean(temp_degree$Degree)
last_five_degree_sd <- sd(temp_degree$Degree)
n <- length(temp_degree$Degree)
# calculate CI
last_five_degree_m
last_five_degree_m + 1.96 * last_five_degree_sd / sqrt(n)
last_five_degree_m - 1.96 * last_five_degree_sd / sqrt(n)
library(ggplot2)
library(gridExtra)
ggplot(dta_all, aes(x = Counter, y = Degree, group = Block)) +
geom_line() + geom_hline(yintercept = last_five_degree_m, linetype = 2) +
facet_wrap( ~ Tester.Name) + theme_bw() +
labs(x = "Trial No: 1 - 24", y = "Degree") +
scale_y_continuous(breaks = seq(0, 175, 25), limits = c(0, 175)) +
theme(legend.position = c(0.8, 0.3))
ggplot(dta_all, aes(x = Counter, y = Degree, group = .)) +
geom_line() + geom_hline(yintercept = last_five_degree_m, linetype = 2) +
facet_wrap( ~ Tester.Name) + theme_bw() +
labs(x = "Trial No: 1 - 24", y = "Degree") +
scale_y_continuous(breaks = seq(0, 175, 25), limits = c(0, 175)) +
theme(legend.position = c(0.8, 0.3))
library(dplyr)
dta_all %>% group_by(Counter) %>%
summarise(trial_m = mean(Degree), trial_sd = sd(Degree))
grp_by_trial <- dta_all %>% group_by(Counter) %>%
summarise(trial_m = mean(Degree), trial_sd = sd(Degree))
grp_by_trial <- as.data.frame(grp_by_trial)
grp_by_trial
dta_by_trial <- dta_all %>% group_by(Counter) %>%
summarise(trial_m = mean(Degree), trial_sd = sd(Degree))
dta_by_trial <- as.data.frame(grp_by_trial)
dta_by_trial
ggplot(dta_by_trial, aes(x = Counter, y = trial_m)) +
geom_errorbar(aes(ymin = trial_m - trial_sd, ymax = trial_m + trial_sd),
width = .2, size = .3) +
geom_line() +
geom_point(size = 4) +
#scale_shape(guide = guide_legend(title = NULL)) +
labs( x = "Trial No: 1 - 24", y = "Mean Degree") +
theme_bw()
ggplot(dta_by_trial, aes(x = Counter, y = trial_m)) +
geom_errorbar(aes(ymin = trial_m - trial_sd, ymax = trial_m + trial_sd),
width = .2, size = .3) +
geom_line() +
geom_point(size = 2) +
#scale_shape(guide = guide_legend(title = NULL)) +
labs( x = "Trial No: 1 - 24", y = "Mean Degree") +
theme_bw() +
theme(legend.position = c(.1, .9))
ggplot(dta_by_trial, aes(x = Counter, y = trial_m)) +
geom_errorbar(aes(ymin = trial_m - trial_sd, ymax = trial_m + trial_sd),
width = .2, size = .3) +
geom_line() +
geom_point(size = 2) +
#scale_shape(guide = guide_legend(title = NULL)) +
labs( x = "Trial No: 1 - 24", y = "Mean Degree") +
theme_bw() +
scale_y_continuous(breaks = seq(0, 175, 25), limits = c(0, 175))
ggplot(dta_all, aes(x = Counter, y = Degree, group = Block)) +
geom_line() + geom_hline(yintercept = last_five_degree_m, linetype = 2) +
facet_wrap( ~ Tester.Name) + theme_bw() +
labs(x = "Trial No: 1 - 24", y = "Degree") +
scale_y_continuous(breaks = seq(0, 175, 25), limits = c(0, 175)) +
theme(legend.position = c(0.8, 0.3))
