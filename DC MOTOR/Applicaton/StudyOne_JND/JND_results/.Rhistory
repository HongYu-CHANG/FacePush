setwd("~/")
update.packages()
## get packages installed
packs = as.data.frame(installed.packages(.libPaths()[1]), stringsAsFactors = F)
## and now re-install install packages using install.packages()
install.packages(packs$Package)
install.packages(packs$Package)
install.packages(packs$Package)
install.packages(packs$Package)
packs = as.data.frame(installed.packages(.libPaths()[1]), stringsAsFactors = F)
packs
library(httr)
update.packages(ask = FALSE)
library(devtools)
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
print
label
labels
argmax
axis
argmax <- function(arr, axis = NULL) {
# Returns the indices of the maximum values along an axis.
# if (length(dim(arr)) != 3) stop("input array doesn't have correct dimension")
if (is.null(axis)) {
which.max(arr)
} else {
apply(arr, MARGIN = axis, which.max)
}
}
argmax
a <- mat(1:6, 2, 3)
a <- matrix(1:6, 2, 3)
a
argmax(a)
argmax(a, axis = 0)
argmax(a, axis = 1)
argmax(a, axis = 2)
is.zero
dim (a)
argmax <- function(arr, axis = NULL) {
# Returns the indices of the maximum values along an axis.
if (axis == 0 || axis > max(dim(arr))) stop("axis doesn't fit the dimension if input array")
# axis in numpy is different with R
if (is.null(axis)) {
which.max(arr)
} else {
apply(arr, MARGIN = axis, which.max)
}
}
argmax(a)
NULL == 0
argmax(a, 5)
NULL > 3
argmax <- function(arr, axis = 0) {
# Returns the indices of the maximum values along an axis.
if (axis > max(dim(arr))) stop("axis doesn't fit the dimension if input array")
# axis in numpy is different with R
if (axis == 0) {
which.max(arr)
} else {
apply(arr, MARGIN = axis, which.max)
}
}
argmax(a)
argmax(a, 2)
argmax(a, 1)
argmax(a, 3)
argmax <- function(arr, axis = 0) {
# Returns the indices of the maximum values along an axis.
if (axis > max(dim(arr))) stop("axis doesn't fit the dimension of input array")
# axis in numpy is different with R
if (axis == 0) {
which.max(arr)
} else {
apply(arr, MARGIN = axis, which.max)
}
}
max(dim(arr))
max(dim(a))
argmax <- function(arr, axis = 0) {
# Returns the indices of the maximum values along an axis.
if (axis > length(dim(arr))) stop("axis doesn't fit the dimension of input array")
# axis in numpy is different with R
if (axis == 0) {
which.max(arr)
} else {
apply(arr, MARGIN = axis, which.max)
}
}
argmax(a, 3)
t
?t
label.p.y.given.x <- function(p.y.given.x) {
t(argmax(p.y.given.x, axis = 3))
}
a = array(1:30, 3, 2, 5)
a
a <- array(1:30, c(3, 2, 5))
a
a <- array(1:30, c(3, 5, 2))
a
label.p.y.given.x(a)
clusters
alpha
a
a[:, :, 0]
a[, , 1]
tc
?stopifnot
getAnywhere(t.test)
getAnywhere(mean)
leibnitz_pi <- function(n = 10) {
stopifnot(is.numeric(n))
stopifnot(n > 0)
est <- 1
for (i in seq(length = n)) {
est <- est + (-1) ^ i / (2 * i + 1)
}
pi_est <- 4 * est
rslt <- list(pi_est = pi_est, n = n)
class(rslt) <- c("leibnitz_pi", "est_pi", class(rslt))
return(rslt)
}
leibnitz_pi(99)
# Implement generic print method for leibnitz_pi
print.leibnitz_pi <- function(x, ...) {
cat(x$pi_est, "(from the Leibnitz formula\n)")
}
print(leibnitz_pi(99))
# Implement generic print method for leibnitz_pi
print.leibnitz_pi <- function(x, ...) {
cat(x$pi_est, "(from the Leibnitz formula)\n")
}
print(leibnitz_pi(99))
methods("print")
methods("print")[grep("leibnitz", methods("print"))]
estpi.leibnitz_pi <- function(x, ...) {
x$estpi
}
estpi(leibnitz_pi(99))
estpi <- function(x, ...) {
UseMethod("estpi", x)
}
estpi.leibnitz_pi <- function(x, ...) {
x$estpi
}
estpi(leibnitz_pi(99))
estpi.leibnitz_pi <- function(x, ...) {
x$est_pi
}
estpi(leibnitz_pi(99))
estpi.leibnitz_pi <- function(x, ...) {
x$pi_est
}
estpi(leibnitz_pi(99))
90 * 0.8
leibnitz_pi(99)
print(leibnitz_pi(99))
attr(leibnitz_pi(99))
# Leibnitz formula for pi
leibnitz_pi <- function(n = 10) {
stopifnot(is.numeric(n))
stopifnot(n > 0)
est <- 1
for (i in seq(length = n)) {
est <- est + (-1) ^ i / (2 * i + 1)
}
pi_est <- 4 * est
rslt <- list(pi_est = pi_est, n = n)
class(rslt) <- c("leibnitz_pi", "est_pi", class(rslt))
return(rslt)
}
print(leibnitz_pi(99))
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
corex
rcorex <- function(n_hidden = 2, dim_hidden = 2, batch_size = 1e6, max_iter = 400,
n_repeat = 1, eps = 1e-6, alpha_hyper = c(0.3, 1.0, 500.0),
balance = 0.0, missing_values = -1, seed = NULL, verbose = False) {
dim_hidden <- dim_hidden  # Each hidden factor can take dim_hidden discrete values
n_hidden <- n_hidden  # Number of hidden factors to use (Y_1,...Y_m) in paper
missing_values <- missing_values  # Implies the value for this variable for this sample is unknown
max_iter <- max_iter  # Maximum number of updates to run, regardless of convergence
batch_size <- batch_size  # TODO: re-implement running with mini-batches
n_repeat <- n_repeat  # TODO: Run multiple times and take solution with largest TC
eps <- eps  # Change in TC to signal convergence
lam <- alpha_hyper[1]  # Hyper-parameters for updating alpha
tmin <- alpha_hyper[2]  # Hyper-parameters for updating alpha
ttc <- alpha_hyper[3]  # Hyper-parameters for updating alpha
balance <- balance # 0 implies no balance constraint. Values between 0 and 1 are valid.
set.seed(seed)  # Set for deterministic results
# change these following into R statements
verbose <- verbose
rslt <- list(dim_hidden = dim_hidden, n_hidden = n_hidden, missing_values = missing_values,
max_iter = max_iter, batch_size = batch_size, n_repeat = n_repeat,
eps = eps, lam = lam, tmin = tmin, ttc = ttc, balance = balance, verbose = verbose)
class(rslt) <- c("rcorex", class(rslt))
return(rslt)
#if (verbose > 0) {
# print options only
# np.set_printoptions(precision=3, suppress=True, linewidth=200) #
# print('corex, rep size: {}, {}'.format(n_hidden, dim_hidden)) #
#}
#if (verbose > 1) {
#  np.seterr(all='warn')
#}
#else {
#  np.seterr(all='ignore')
#}
}
rcorex()
rcorex <- function(n_hidden = 2, dim_hidden = 2, batch_size = 1e6, max_iter = 400,
n_repeat = 1, eps = 1e-6, alpha_hyper = c(0.3, 1.0, 500.0),
balance = 0.0, missing_values = -1, seed = NULL, verbose = FALSE) {
dim_hidden <- dim_hidden  # Each hidden factor can take dim_hidden discrete values
n_hidden <- n_hidden  # Number of hidden factors to use (Y_1,...Y_m) in paper
missing_values <- missing_values  # Implies the value for this variable for this sample is unknown
max_iter <- max_iter  # Maximum number of updates to run, regardless of convergence
batch_size <- batch_size  # TODO: re-implement running with mini-batches
n_repeat <- n_repeat  # TODO: Run multiple times and take solution with largest TC
eps <- eps  # Change in TC to signal convergence
lam <- alpha_hyper[1]  # Hyper-parameters for updating alpha
tmin <- alpha_hyper[2]  # Hyper-parameters for updating alpha
ttc <- alpha_hyper[3]  # Hyper-parameters for updating alpha
balance <- balance # 0 implies no balance constraint. Values between 0 and 1 are valid.
set.seed(seed)  # Set for deterministic results
# change these following into R statements
verbose <- verbose
rslt <- list(dim_hidden = dim_hidden, n_hidden = n_hidden, missing_values = missing_values,
max_iter = max_iter, batch_size = batch_size, n_repeat = n_repeat,
eps = eps, lam = lam, tmin = tmin, ttc = ttc, balance = balance, verbose = verbose)
class(rslt) <- c("rcorex", class(rslt))
return(rslt)
#if (verbose > 0) {
# print options only
# np.set_printoptions(precision=3, suppress=True, linewidth=200) #
# print('corex, rep size: {}, {}'.format(n_hidden, dim_hidden)) #
#}
#if (verbose > 1) {
#  np.seterr(all='warn')
#}
#else {
#  np.seterr(all='ignore')
#}
}
rcorex()
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
label_p_y_given_x <- function(p_y_given_x, ...) {
UseMethod("label_p_y_given_x", p_y_given_x)
}
label_p_y_given_x <- function(rcorex, ...) {
UseMethod("label_p_y_given_x", rcorex)
}
label_p_y_given_x.corex <- function(rcorex, ...) {
# Maximum likelihood labels for some distribution over y's
t(argmax(rcorex$p_y_given_x, axis = 3))
}
corex
rcorex()
label_p_y_given_x.rcorex <- function(rcorex, ...) {
# Maximum likelihood labels for some distribution over y's
t(argmax(rcorex$p_y_given_x, axis = 3))
}
label_p_y_given_x(rcorex())
rcorex
rcorex()
rcorex()$p_y_given_x
#
# @property in R?
ml_labels <- function(rcorex, ...) {
UseMethod("ml_lables", rcorex)
}
ml_labels.rcorex <- function(rcorex, ...) {
# maximum likelihood labels for trainging data
label_p_y_given_x()
}
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
seq(5)
seq(5-1)
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
install.packages("fread")
install.packages("data.table")
install.packages("tidyverse")
install.packages("shiny", "rmarkdown")
install.packages("shiny")
install.packages("rmarkdown")
install.packages("xgboost")
install.packages("ggmap")
install.packages("rgl")
install.packages("grep")
getAnywhere("grep")
install.packages("stringr")
install.packages("e1071")
install.packages("nnet")
setwd("~/Documents/_NILab_CrazyMotor/FacePush/DC MOTOR/Applicaton/StudyOne_JND/JND_results/")
file_names <- dir()[grep("csv", dir())]
lst <- lapply(file_names, function(x) read.table(x, header = FALSE, sep = ','))
lst[[1]]
library(data.table)
# do.call("rbind", lst)
dta <- rbindlist(lst)
names(dta) <- c("TrialNo", "Base", "Offset", "Response", "RT")
dta$Subject <- rep(paste0("U", 1:9), each = 32)
library(dplyr)
result <- dta %>% group_by(Base, Offset) %>%
summarise(Counts = sum(Response))
result <- as.data.frame(result)
result_mat <- round(matrix(result$Counts, c(4, 4), byrow = FALSE) / 18, 2)
dimnames(result_mat) <- list(c(0, 0.125, 0.25, 0.5), c(2.575, 2.7, 2.95, 3.45))
result_mat <- abs(result_mat - 1)
library(corrplot)
library(RColorBrewer)
# fitting data
result_mat
off <- c(0, 0.125, 0.25, 0.5)
base <- c(2.575, 2.7, 2.95, 3.45)
all_off <- outer(off, base, FUN = "+")
ob_b <- sweep(all_off, 2, base, FUN = "/")
out <- data.frame(rate_diff = as.vector(result_mat),
delta_load_base = as.vector(ob_b))
m0 <- lm(rate_diff ~ log(delta_load_base), data = out)
plot(rate_diff ~ log(delta_load_base) , data = out)
lines(log(out$delta_load_base), predict(m0))
out2 <- out[1:12,]
m1 <- lm(rate_diff ~ log(delta_load_base) , data = out2)
summary(m0)
summary(m1)
x <- seq(from = 1, to = 1.5, by = 0.01)
pred_percent1 <- round(coef(m1)[1] + coef(m1)[2] * log(x), 2)
# delat L/ L = 1.21
x[which(pred_percent1 == 0.95)]
x[which(pred_percent1 == 0.75)]
x[which(pred_percent1 == 0.74)]
pred_percent1
x <- seq(from = 1, to = 1.5, by = 0.001)
pred_percent1 <- round(coef(m1)[1] + coef(m1)[2] * log(x), 2)
# delat L/ L = 1.21
x[which(pred_percent1 == 0.95)]
x[which(pred_percent1 == 0.74)]
x[which(pred_percent1 == 0.75)]
#
base
#
data.frame(Base = base, LoadJND = base + off)
#
test <- data.frame(Base = base, LoadJND = base + off)
ggplot(test, aes(x = Base, y = LoadJND)) +
geom_point()
library(ggplot2)
ggplot(test, aes(x = Base, y = LoadJND)) +
geom_point()
ggplot(test, aes(x = Base, y = LoadJND)) +
geom_point() +
limits(x = c(0, 4), y = c(0, 4))
ggplot(test, aes(x = Base, y = LoadJND)) +
geom_point() +
scale_x_continuous(limits = c(0, 4)) +
scale_y_continuous(limits = c(0, 4))
ggplot(test, aes(x = Base, y = LoadJND)) +
geom_point() +
geom_abline(slope = 1.25) +
scale_x_continuous(limits = c(0, 4)) +
scale_y_continuous(limits = c(0, 4))
ggplot(test, aes(x = Base, y = LoadJND)) +
geom_point() +
geom_abline(slope = 1.21) +
scale_x_continuous(limits = c(0, 4)) +
scale_y_continuous(limits = c(0, 4))
base
ggplot(test, aes(x = Base, y = LoadJND)) +
geom_point() +
geom_abline(slope = 1.25, intercept = 2.575) +
scale_x_continuous(limits = c(0, 4)) +
scale_y_continuous(limits = c(0, 4))
ggplot(test, aes(x = Base, y = LoadJND)) +
geom_point() +
geom_abline(slope = 1.25, intercept = -2.575) +
scale_x_continuous(limits = c(0, 4)) +
scale_y_continuous(limits = c(0, 4))
