setwd("~/")
update.packages()
## get packages installed
packs = as.data.frame(installed.packages(.libPaths()[1]), stringsAsFactors = F)
## and now re-install install packages using install.packages()
install.packages(packs$Package)
install.packages(packs$Package)
install.packages(packs$Package)
install.packages(packs$Package)
packs = as.data.frame(installed.packages(.libPaths()[1]), stringsAsFactors = F)
packs
library(httr)
update.packages(ask = FALSE)
library(devtools)
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
print
label
labels
argmax
axis
argmax <- function(arr, axis = NULL) {
# Returns the indices of the maximum values along an axis.
# if (length(dim(arr)) != 3) stop("input array doesn't have correct dimension")
if (is.null(axis)) {
which.max(arr)
} else {
apply(arr, MARGIN = axis, which.max)
}
}
argmax
a <- mat(1:6, 2, 3)
a <- matrix(1:6, 2, 3)
a
argmax(a)
argmax(a, axis = 0)
argmax(a, axis = 1)
argmax(a, axis = 2)
is.zero
dim (a)
argmax <- function(arr, axis = NULL) {
# Returns the indices of the maximum values along an axis.
if (axis == 0 || axis > max(dim(arr))) stop("axis doesn't fit the dimension if input array")
# axis in numpy is different with R
if (is.null(axis)) {
which.max(arr)
} else {
apply(arr, MARGIN = axis, which.max)
}
}
argmax(a)
NULL == 0
argmax(a, 5)
NULL > 3
argmax <- function(arr, axis = 0) {
# Returns the indices of the maximum values along an axis.
if (axis > max(dim(arr))) stop("axis doesn't fit the dimension if input array")
# axis in numpy is different with R
if (axis == 0) {
which.max(arr)
} else {
apply(arr, MARGIN = axis, which.max)
}
}
argmax(a)
argmax(a, 2)
argmax(a, 1)
argmax(a, 3)
argmax <- function(arr, axis = 0) {
# Returns the indices of the maximum values along an axis.
if (axis > max(dim(arr))) stop("axis doesn't fit the dimension of input array")
# axis in numpy is different with R
if (axis == 0) {
which.max(arr)
} else {
apply(arr, MARGIN = axis, which.max)
}
}
max(dim(arr))
max(dim(a))
argmax <- function(arr, axis = 0) {
# Returns the indices of the maximum values along an axis.
if (axis > length(dim(arr))) stop("axis doesn't fit the dimension of input array")
# axis in numpy is different with R
if (axis == 0) {
which.max(arr)
} else {
apply(arr, MARGIN = axis, which.max)
}
}
argmax(a, 3)
t
?t
label.p.y.given.x <- function(p.y.given.x) {
t(argmax(p.y.given.x, axis = 3))
}
a = array(1:30, 3, 2, 5)
a
a <- array(1:30, c(3, 2, 5))
a
a <- array(1:30, c(3, 5, 2))
a
label.p.y.given.x(a)
clusters
alpha
a
a[:, :, 0]
a[, , 1]
tc
?stopifnot
getAnywhere(t.test)
getAnywhere(mean)
leibnitz_pi <- function(n = 10) {
stopifnot(is.numeric(n))
stopifnot(n > 0)
est <- 1
for (i in seq(length = n)) {
est <- est + (-1) ^ i / (2 * i + 1)
}
pi_est <- 4 * est
rslt <- list(pi_est = pi_est, n = n)
class(rslt) <- c("leibnitz_pi", "est_pi", class(rslt))
return(rslt)
}
leibnitz_pi(99)
# Implement generic print method for leibnitz_pi
print.leibnitz_pi <- function(x, ...) {
cat(x$pi_est, "(from the Leibnitz formula\n)")
}
print(leibnitz_pi(99))
# Implement generic print method for leibnitz_pi
print.leibnitz_pi <- function(x, ...) {
cat(x$pi_est, "(from the Leibnitz formula)\n")
}
print(leibnitz_pi(99))
methods("print")
methods("print")[grep("leibnitz", methods("print"))]
estpi.leibnitz_pi <- function(x, ...) {
x$estpi
}
estpi(leibnitz_pi(99))
estpi <- function(x, ...) {
UseMethod("estpi", x)
}
estpi.leibnitz_pi <- function(x, ...) {
x$estpi
}
estpi(leibnitz_pi(99))
estpi.leibnitz_pi <- function(x, ...) {
x$est_pi
}
estpi(leibnitz_pi(99))
estpi.leibnitz_pi <- function(x, ...) {
x$pi_est
}
estpi(leibnitz_pi(99))
90 * 0.8
leibnitz_pi(99)
print(leibnitz_pi(99))
attr(leibnitz_pi(99))
# Leibnitz formula for pi
leibnitz_pi <- function(n = 10) {
stopifnot(is.numeric(n))
stopifnot(n > 0)
est <- 1
for (i in seq(length = n)) {
est <- est + (-1) ^ i / (2 * i + 1)
}
pi_est <- 4 * est
rslt <- list(pi_est = pi_est, n = n)
class(rslt) <- c("leibnitz_pi", "est_pi", class(rslt))
return(rslt)
}
print(leibnitz_pi(99))
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
corex
rcorex <- function(n_hidden = 2, dim_hidden = 2, batch_size = 1e6, max_iter = 400,
n_repeat = 1, eps = 1e-6, alpha_hyper = c(0.3, 1.0, 500.0),
balance = 0.0, missing_values = -1, seed = NULL, verbose = False) {
dim_hidden <- dim_hidden  # Each hidden factor can take dim_hidden discrete values
n_hidden <- n_hidden  # Number of hidden factors to use (Y_1,...Y_m) in paper
missing_values <- missing_values  # Implies the value for this variable for this sample is unknown
max_iter <- max_iter  # Maximum number of updates to run, regardless of convergence
batch_size <- batch_size  # TODO: re-implement running with mini-batches
n_repeat <- n_repeat  # TODO: Run multiple times and take solution with largest TC
eps <- eps  # Change in TC to signal convergence
lam <- alpha_hyper[1]  # Hyper-parameters for updating alpha
tmin <- alpha_hyper[2]  # Hyper-parameters for updating alpha
ttc <- alpha_hyper[3]  # Hyper-parameters for updating alpha
balance <- balance # 0 implies no balance constraint. Values between 0 and 1 are valid.
set.seed(seed)  # Set for deterministic results
# change these following into R statements
verbose <- verbose
rslt <- list(dim_hidden = dim_hidden, n_hidden = n_hidden, missing_values = missing_values,
max_iter = max_iter, batch_size = batch_size, n_repeat = n_repeat,
eps = eps, lam = lam, tmin = tmin, ttc = ttc, balance = balance, verbose = verbose)
class(rslt) <- c("rcorex", class(rslt))
return(rslt)
#if (verbose > 0) {
# print options only
# np.set_printoptions(precision=3, suppress=True, linewidth=200) #
# print('corex, rep size: {}, {}'.format(n_hidden, dim_hidden)) #
#}
#if (verbose > 1) {
#  np.seterr(all='warn')
#}
#else {
#  np.seterr(all='ignore')
#}
}
rcorex()
rcorex <- function(n_hidden = 2, dim_hidden = 2, batch_size = 1e6, max_iter = 400,
n_repeat = 1, eps = 1e-6, alpha_hyper = c(0.3, 1.0, 500.0),
balance = 0.0, missing_values = -1, seed = NULL, verbose = FALSE) {
dim_hidden <- dim_hidden  # Each hidden factor can take dim_hidden discrete values
n_hidden <- n_hidden  # Number of hidden factors to use (Y_1,...Y_m) in paper
missing_values <- missing_values  # Implies the value for this variable for this sample is unknown
max_iter <- max_iter  # Maximum number of updates to run, regardless of convergence
batch_size <- batch_size  # TODO: re-implement running with mini-batches
n_repeat <- n_repeat  # TODO: Run multiple times and take solution with largest TC
eps <- eps  # Change in TC to signal convergence
lam <- alpha_hyper[1]  # Hyper-parameters for updating alpha
tmin <- alpha_hyper[2]  # Hyper-parameters for updating alpha
ttc <- alpha_hyper[3]  # Hyper-parameters for updating alpha
balance <- balance # 0 implies no balance constraint. Values between 0 and 1 are valid.
set.seed(seed)  # Set for deterministic results
# change these following into R statements
verbose <- verbose
rslt <- list(dim_hidden = dim_hidden, n_hidden = n_hidden, missing_values = missing_values,
max_iter = max_iter, batch_size = batch_size, n_repeat = n_repeat,
eps = eps, lam = lam, tmin = tmin, ttc = ttc, balance = balance, verbose = verbose)
class(rslt) <- c("rcorex", class(rslt))
return(rslt)
#if (verbose > 0) {
# print options only
# np.set_printoptions(precision=3, suppress=True, linewidth=200) #
# print('corex, rep size: {}, {}'.format(n_hidden, dim_hidden)) #
#}
#if (verbose > 1) {
#  np.seterr(all='warn')
#}
#else {
#  np.seterr(all='ignore')
#}
}
rcorex()
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
label_p_y_given_x <- function(p_y_given_x, ...) {
UseMethod("label_p_y_given_x", p_y_given_x)
}
label_p_y_given_x <- function(rcorex, ...) {
UseMethod("label_p_y_given_x", rcorex)
}
label_p_y_given_x.corex <- function(rcorex, ...) {
# Maximum likelihood labels for some distribution over y's
t(argmax(rcorex$p_y_given_x, axis = 3))
}
corex
rcorex()
label_p_y_given_x.rcorex <- function(rcorex, ...) {
# Maximum likelihood labels for some distribution over y's
t(argmax(rcorex$p_y_given_x, axis = 3))
}
label_p_y_given_x(rcorex())
rcorex
rcorex()
rcorex()$p_y_given_x
#
# @property in R?
ml_labels <- function(rcorex, ...) {
UseMethod("ml_lables", rcorex)
}
ml_labels.rcorex <- function(rcorex, ...) {
# maximum likelihood labels for trainging data
label_p_y_given_x()
}
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
seq(5)
seq(5-1)
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
source('~/Documents/_18S_CF_Project/CorEx/rcorex.R')
install.packages("fread")
install.packages("data.table")
install.packages("tidyverse")
install.packages("shiny", "rmarkdown")
install.packages("shiny")
install.packages("rmarkdown")
install.packages("xgboost")
install.packages("ggmap")
install.packages("rgl")
install.packages("grep")
getAnywhere("grep")
install.packages("stringr")
install.packages("e1071")
install.packages("nnet")
setwd("~/Documents/_NILab_CrazyMotor/FacePush/DC MOTOR/Applicaton/Boxer Game/Results/")
library(data.table)
data_files <- dir()[-c(53, 54)]
dta_lst <- lapply(data_files, function(x) fread(x, sep = ',', stringsAsFactors = FALSE))
data_files
data_files <- dir()[-c(53:56)]
dta_lst <- lapply(data_files, function(x) fread(x, sep = ',', stringsAsFactors = FALSE))
#
dta_rows <- unlist(lapply(dta_lst, function(x) dim(x)[1]))
which(dta_rows == 979)
which(dta_rows == 1396)
data_files[c(33, 40)]
#
dta <- rbindlist(dta_lst)
# read data
library(data.table)
dir()
data_files <- dir()[-c(53:58)]
dta_lst <- lapply(data_files, function(x) fread(x, sep = ',', stringsAsFactors = FALSE))
#
dta_rows <- unlist(lapply(dta_lst, function(x) dim(x)[1]))
#
dta <- rbindlist(dta_lst)
str(dta)
dta$send2motor <- as.factor(as.integer(dta$send2motor))
dta$punch_type <- as.factor(dta$punch_type)
levels(dta$punch_type) <- c("heavy_R", "heavy_L", "light_R", "light_L", "light_hook")
dta$motor_data <- as.factor(dta$motor_data)
levels(dta$motor_data) <- c("no_cmd", "back_neutral", "R_light", "R_heavy", "L_light",
"M_light", "R_heavy", "M_heavy")
str(dta)
idx <- which(dta$send2motor == TRUE)
# add condition and subject
condition_subject <- unlist(lapply(data_files, function(x) unlist(strsplit(x, '[.]'))[1]))
cs_lst <- unlist(lapply(condition_subject, function(x) strsplit(x, '_')))
cs_lst <- as.data.frame(t(matrix(cs_lst, c(2, 52))))
dta$Condition <- rep(cs_lst$V1, dta_rows)
dta$Subject <- rep(cs_lst$V2, dta_rows)
dta <- subset(dta, dta$Subject != "Byran")
library(ggplot2)
ggplot(dta, aes(x = HMD_pos.x, y = HMD_pos.y, color = Condition)) +
geom_point() +
facet_wrap(Subject)
ggplot(dta, aes(x = HMD_pos.x, y = HMD_pos.y, color = Condition)) +
geom_point() +
facet_wrap(. ~ Subject)
ggplot(dta, aes(x = HMD_pos.x, y = HMD_pos.y, color = Condition)) +
geom_point() +
facet_wrap(Subject ~)
ggplot(dta, aes(x = HMD_pos.x, y = HMD_pos.y, color = Condition)) +
geom_point() +
facet_wrap(Subject ~ .)
?facet_wrap
ggplot(dta, aes(x = HMD_pos.x, y = HMD_pos.y, color = Condition)) +
geom_point() +
facet_wrap(~Subject)
ggplot(dta, aes(x = HMD_pos.x, y = HMD_pos.y, color = Condition)) +
geom_point() +
facet_wrap(~Subject)
dta <- subset(dta, dta$Subject != "BYRAN")
ggplot(dta, aes(x = HMD_pos.x, y = HMD_pos.z, color = Condition)) +
geom_point(size = 0.5) +
facet_wrap(~ Subject) +
scale_x_continuous(limits = c(-1, 1)) +
scale_y_continuous(limits = c(-5, 5))
ggplot(dta, aes(x = HMD_pos.x, y = HMD_pos.z, color = Condition)) +
geom_point(size = 0.5) +
facet_wrap(~ Subject) +
scale_x_continuous(limits = c(-3, 3)) +
scale_y_continuous(limits = c(-3, 3))
?scale
ggplot(dta, aes(x = scale(HMD_pos.x), y = scale(HMD_pos.z), color = Condition)) +
geom_point(size = 0.5) +
facet_wrap(~ Subject) +
scale_x_continuous(limits = c(-3, 3)) +
scale_y_continuous(limits = c(-3, 3))
dta$Subject
dta <- subset(dta, dta$Subject != "BRYAN")
ggplot(dta, aes(x = scale(HMD_pos.x), y = scale(HMD_pos.z), color = Condition)) +
geom_point(size = 0.5) +
facet_wrap(~ Subject) +
scale_x_continuous(limits = c(-5, 5)) +
scale_y_continuous(limits = c(-5, 5))
library(ggplot2)
ggplot(dta, aes(x = scale(HMD_pos.y), y = scale(HMD_pos.z), color = Condition)) +
geom_point(size = 0.5) +
facet_wrap(~ Subject) +
scale_x_continuous(limits = c(-5, 5)) +
scale_y_continuous(limits = c(-5, 5))
ggplot(dta, aes(x = scale(HMD_pos.x), y = scale(HMD_pos.z), color = Condition)) +
geom_point(size = 0.5) +
facet_wrap(~ Subject) +
scale_x_continuous(limits = c(-5, 5)) +
scale_y_continuous(limits = c(-5, 5))
scale(dta$HMD_pos.x)
dta$new_pos_x <- scale(dta$HMD_pos.x)
dta$new_pos_z <- scale(dta$HMD_pos.z)
ggplot(dta, aes(x = new_pos_x, y = new_pos_z, color = Condition)) +
geom_point(size = 0.5) +
facet_wrap(~ Subject) +
scale_x_continuous(limits = c(-1, 1)) +
scale_y_continuous(limits = c(-1, 1))
ggplot(dta, aes(x = new_pos_x, y = new_pos_z, color = Condition)) +
geom_point(size = 0.5) +
facet_wrap(~ Subject) +
scale_x_continuous(limits = c(-2, 2)) +
scale_y_continuous(limits = c(-2, 2))
ggplot(dta, aes(x = new_pos_x, y = new_pos_z, color = Condition)) +
geom_point(size = 0.5) +
facet_wrap(~ Subject) +
scale_x_continuous(limits = c(-6, 6)) +
scale_y_continuous(limits = c(-6, 6))
ggplot(dta, aes(x = new_pos_x, y = new_pos_z, color = Condition)) +
geom_point(size = 0.5) +
facet_wrap(~ Subject) +
scale_x_continuous(limits = c(-5, 5)) +
scale_y_continuous(limits = c(-5, 5))
ggplot(dta, aes(x = new_pos_x, y = new_pos_z, color = Condition)) +
#geom_point(size = 0.5) +
geom_line() +
facet_wrap(~ Subject) +
scale_x_continuous(limits = c(-5, 5)) +
scale_y_continuous(limits = c(-5, 5))
ggplot(dta, aes(x = new_pos_x, y = new_pos_z, color = Condition)) +
geom_point(size = 0.5) +
#geom_line() +
facet_wrap(~ Subject) +
scale_x_continuous(limits = c(-5, 5)) +
scale_y_continuous(limits = c(-5, 5))
length(dta$HMD_rot.y)
dta$new_rot_y <- dta$HMD_rot.y - c(dta$HMD_rot.y[-1], dta$HMD_rot.y[length(dta$HMD_rot.y)])
ggplot(dta, aes(x = 1:length(dta$HMD_rot.y), y = new_rot_y, color = Condition)) +
geom_line() +
#geom_line() +
facet_wrap(~ Subject)
dta_rows
ggplot(dta, aes(x = 1:1396, y = new_rot_y, color = Condition)) +
geom_line() +
#geom_line() +
facet_wrap(~ Subject)
iter <- NULL
for (i in length(dta_rows)) {
iter <- c(iter, 1:dta_rows[i])
}
iter
iter <- NULL
for (i in length(dta_rows)) {
iter <- c(iter, 1:dta_rows[i])
}
iter
dta_rows
table(dta$Subject)
dta
data_files
dta_rows <- dta_rows[-c(1, 14, 27, 40)]
dta_rows
iter <- NULL
for (i in length(dta_rows)) {
iter <- c(iter, seq(1:dta_rows[i]))
}
iter
iter <- NULL
for (i in 1:length(dta_rows)) {
iter <- c(iter, seq(1:dta_rows[i]))
}
iter
dta$iter <- iter
ggplot(dta, aes(x = iter, y = new_rot_y, color = Condition)) +
geom_line() +
#geom_line() +
facet_wrap(~ Subject)
# adjust rotation x, y, and z of HMD
dta$new_HMD_rot_x <-vapply(dta$HMD_rot.x, function(x) ifelse(x > 180, x - 360, x), numeric(1))
dta$new_HMD_rot_y <-vapply(dta$HMD_rot.y, function(x) ifelse(x > 180, x - 360, x), numeric(1))
dta$new_HMD_rot_z <-vapply(dta$HMD_rot.z, function(x) ifelse(x > 180, x - 360, x), numeric(1))
dta$new_rot_y <- dta$HMD_rot.y - c(dta$HMD_rot.y[-1], dta$HMD_rot.y[length(dta$HMD_rot.y)])
ggplot(dta, aes(x = iter, y = new_rot_y, color = Condition)) +
geom_line() +
#geom_line() +
facet_wrap(~ Subject)
dta$new_rot_y <- dta$new_HMD_rot_y - c(dta$new_HMD_rot_y[-1], dta$new_HMD_rot_y[length(dta$new_HMD_rot_y)])
ggplot(dta, aes(x = iter, y = new_rot_y, color = Condition)) +
geom_line() +
#geom_line() +
facet_wrap(~ Subject)
ggplot(dta, aes(x = iter, y = new_rot_y, color = Condition)) +
geom_line() +
#geom_line() +
facet_wrap(~ Subject) +
scale_y_continuous(limits = c(-50, 50))
ggplot(dta, aes(x = iter, y = new_rot_y, color = Condition)) +
geom_line() +
#geom_line() +
facet_wrap(~ Subject) +
scale_y_continuous(limits = c(-25, 25))
